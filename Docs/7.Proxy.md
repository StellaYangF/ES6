### Proxy
#### 1. Introduction
* Proxy is a kind of meta programming
* Grammer:
 ```
  let proxy = new Proxy(target, handler);
 ```
 * Preview
 ```
  let handler = {
    get (target, name)  {
      if (name === 'prototype') {
        return Object.prototype;
      }
      return 'Hello, ' + name;
    },

    apply (target, thisBingding, args) {
      return args[0];
    },

    construct (target, args) {
      return { value: args[1]};
    }
  }

  // 此处不用箭头函数做target对象，箭头函数不能做构造函数
  let fproxy = new Proxy( function(x,y){
    return x + y;
  }, handler);

  fproxy(1,2); //1
  // invoke handler.apply()

  new fproxy(1,2);  // {value: 2};
  // invoke handler.construct()
  
  fproxy.property === Object.prototype;  // true
  fproxy.hello = 'Hello, hello'; // Hello, hello
  // invoke handler.get()
 ```

#### 2. Proxy supports methods: Instance methods
##### 1. get(target, property, receiver)
* 1.1 重写.运算符
```
  let person = {
    name: 'Tom',
  };

  let proxy = new Proxy(person, {
    get (target, property) {
      if( property in target)  return target[property]
      else throw new ReferenceError(`Propery "${property}" does not exist.`)
    }
  })

  console.log(proxy.name) // Tom
  console.log(proxy.age) // Error
```

* 1.2 实现属性链式操作
```
  // Cannot use let decleration
  var double = n => n * 2;
  var pow = n => n* n;
  var reverseInt = n => n.toString().split("").reverse().join("") | 0;

  let pipe = (()=>{
    return value => {
      const GET = 'get';
      let funcStack = [];
      let target = {};
      let handler = {
        get (target, fnName, receiver) {
          if (fnName === GET) {
            return funcStack.reduce((value, fn) => fn(value), value);
          }
          funcStack.push(window[fnName]);
          return receiver;
        }
      };
      let proxy = new Proxy(target,handler);
      return proxy;
    }
  })();

  pipe(5).pow.double.reverseInt.get;  // 5
```

* 1.3 get拦截，生成dom节点
```
let target = {};
let handler = {
  get (target , property, receiver) {
    return ( attrs = {}, ...children ) => {
      const el = document.createElement(property);
      Object.keys(attrs).map(prop => {
        el.setAttribute(prop, attrs[prop]);
      });
      children.map(child => {
        child = typeof child === 'string' &&  document.createTextNode(child);
        el.appendChild(child);
      })

      return el;
    }
  }
};
const dom = new Proxy(target, handler);
const el = dom.div({},'hello');     
// <div>hello</div>
```

* 1.4 不可配置且不可写的属性，proxy在修改时会报错
```
const target = Object.defineProperty({}, 'foo', {
  value: 123,
  writable: false,
  configurable: false,
})

const handler = {
  get (target, property) {
    return 'abc';
  }
}
const proxy = new Proxy(target, handler);
proxy.foo;
// Uncaught TypeError: 'get' on proxy: 
// property 'foo' is a read-only and non-configurable data property 
// on the proxy target but the proxy did not return its actual value 
// (expected '123' but got 'abc')
```

* 1.5 实现继承
```
let proto = new Proxy({}, {
  get (target, property, receiver) {
    console.log(`GET ${property}`);
    return target[property] && undefined;
  }
});

let obj = Object.create(proto);
console.log(obj.name);
// GET name
// undefined
```

* 1.6 实现数组读取负数
```
function createArray (...elements) {
  let handler = {
    get (target, property, receiver) {
      let index = Number(property);
      property =  index < 0 ? String(target.length + index): index;
      return Reflect.get(target, property, receiver);
    }
  };

  let target = [...elements];
  return new Proxy(target, handler);
}

let arr = createArray('a', 'b', 'c');
console.log(arr[-1], arr[1]);
```

##### 2. set
* 定义： set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选
```
  let validator = {
    set (target, property, value, receiver) {
      if (property  === 'age') {
        if ( !Number.isInteger(value) {
          throw new TypeError('The age is not an integer');
        }
        if (value > 200) {
          throw new RangeError('The age seems invalid');
        }
      }
      obj[property] = value;
    }
  }
  const target = {};
  let person = new Proxy(target, validator);

  person.age = 100;
  person.age //100
  person.age = 'young'; //Error
  person.age = 300; //Errors
```

* 2.1 应用：内部属性不被读写
```
  // 工具函数
  const invariant = (key, action) => {
    if (key[0] === '_') {
      throw new Error(`Invalid attempt to ${action} private "${key}" property`);
    }
  }
  const GET = 'get';
  const SET = 'set';
  const target = {};

  const handler = {
    get (target, key) {
      invariant(key, GET);
      return target[key];
    },
    set (target, key, value) {
      invariant(key, SET);
      target[key] = value;
      return true;
    }
  };
  const proxy = new Proxy(target, handler);
  proxy._prop;
  proxy._prop = 'c';
  // Error: Invalid attempt to get private "_prop" property
```

* 2.2 应用：严格模式下，不返回true报错
```
  'use strict';
  const handler = {
    set (target, prop, value, receiver) {
      target[prop] = receiver;
      // 无论是否有下面这行，都会报错，或返回值为undefined
      return false;
    }
  }
  const proxy = new Proxy({},handler);
  proxy.foo = 'bar';
  // Uncaught TypeError: 'set' on proxy: trap returned falsish for property 'foo'
```

##### 3. apply
* apply方法拦截函数的调用、call 和 apply操作
* three params: target, this, args
```
// example1: 
  const handler = {
    apply (target, ctx, args)  {
      return Reflect.apply(...arguments);
    }
  }

// exmpale2 :
  const target = () => 'I am the target';
  const handler = {
    apply () {
      return 'I am the proxy';
    }
  }
  const p = new Proxy(target, handler);
  p();    // I am the proxy;

// exmample3:
  const twice = {
    apply (target, ctx, args) {
      return Reflect.apply(...arguments) * 2;
    }
  };
  function sum (left, right) {
    return left  + right;
  };
  const proxy = new Proxy(sum, twice);
  proxy(1,2);   // 6
  proxy.call(null, 2, 3);  // 10
  proxy.apply(null, [ 3, 4 ]); // 14
  Reflect.apply(proxy, null, [ 5, 6 ]); // 22
```

##### 4. has
* 拦截HasProperty操作， 典型操作为in运算符
* params: target, propertyName
```
  const handler = {
    has (target, property) {
      if (property[0]=== '_') return false;
      return property in target;
    }
  }
  const target = {_prop: "foo", prop: "foo"};
  const proxy = new Proxy(target, handler);
  Reflect.has(proxy, '_prop');    // false
  '_prop' in proxy;   // false
  Reflect.has(proxy, 'prop');   //  true
```

* 原对象不可配置或禁止扩展，has拦截报错
```
  const obj = { a: 10 };
  Object.preventExtensions(obj);
  const p = new Proxy(obj, {
    has (target, prop) { 
      return false;
    }
  });
  "a" in p;
  // Uncaught TypeError: 'has' on proxy: trap returned falsish for property 'a' but the proxy target is not extensible
```

* has拦截的是HasProperty而非HasOwnProperty
```
  // has方法不判断一个属性是对象自身属性还是继承属性
  "constructor" in p;   // false
```

* has拦截对for...in循环不生效
```
  let stu1 = { name: "Lily", score: 59 };
  let stu2 = { name: "Eva", score : 99 };
  let handler = {
    has (target, prop) {
      if (prop === 'score' && target[prop] < 60) {
        console.log(`${target.name} failed`);
        return false;
      }
      return prop in target;
    }
  }
  let p1 = new Proxy(stu1, handler);
  let p2 = new Proxy(stu2, handler);
  'score' in p1;    // Lily failed false
  'score' in p2;    // true

  for (let a in p1) {
    console.log(p1[a]);
  }
  // Lily 59
  for (let a in p2) {
    console.log(p2[a]);
  }
  // Eva 99
```

##### 5. construct
* 拦截new命令
* params: 
  1. target: 目标对象, 
  2. args: 构造函数参数对象, 
  3. newTarget: 创造实例对象时，new命令作用的构造函数
```
// example 1:
  const handler = {
    construct (target, args) {
      console.log(args);
      console.log('called: ' + args.join(', '));
      return { value: args[0] * 10};
    }
  };

  const p = new Proxy(function () {},handler);
  (new p(1)).value;   
  // called: 1
  // 10

// example 2： 
  // 返回必须是对象，否则报错
  const p = new Proxy(function () {}, {
    construct (target, args) {
      return 1;
    }
  })
  new p();
```

##### 6. deleteProperty
* 拦截delete操作，若抛出错误或返回false，当前属性无法被delete命令删除
```
  const handler = {
    deleteProperty (target, key) {
      invariant(key, 'deleite');
      delete target[key];
      return true;
    }
  }

  function invariant (key, action) {
    if (key[0] === '_') throw new Error(`Invalid atttempt to ${action} private ${key} property`);
  }

  const target = { _prop: "foo" };
  const p = new Proxy(target, handler);
  delete p._prop;
  // Uncaught Error: Invalid atttempt to deleite private _prop property
```

##### 6. defineProperty
* 拦截Object.defineProperty
```
  const handler = {
    defineProperty (target, key, descriptor) {
      return false;
    }
  }
  const target = {};
  const p = new Proxy(target, handler);

  p.foo = 'bar';  // no effect
```

* 6.1 目标对象不可拓展，则该方法不能添加目标对象不存在的属性，否则报错
```
  const target = { name: 'lily'};
  Object.preventExtensions(target);
  const handler = {
    defineProperty (target, key, descriptor) {
      return true;
    }
  }
  const p = new Proxy(target, handler);
  p.age = 'tom';
  // Uncaught TypeError: 'defineProperty' on proxy: 
  // trap returned truish for adding property 'age'  
  // to the non-extensible proxy target
```

* 6.2 目标对象某属性不可写或不可配置，则该方法不得改变两个设置
```
  const target = { name: 'lily'};
  Object.defineProperty(target, 'age', {
    value: 20,
    writable: false,
    enumerable: true,
    configurable: true
  })
  const handler = {
    defineProperty (target, key, descriptor) {
      return true;
    }
  }
  const p = new Proxy(target, handler);
  p.age = 28; //no effect
```
