# 一、Class 基础语法
## 1. 简介
```js
class Point {
  constructor (x, y) {
    this.y = y;
    this.x = x;
  }
  
  toString() {
    return `(${this.x}, ${this.y})`;
  }
}

typeof Point;
// "function"
Point === Point.prototype.constructor;
// 类本身指向 构造函数
```

### 1.1 在类的实例上面调用方法，其实就是调用原型上的方法。
```js
class Point {
  constructor() {}

  toString() {}

  toValue() {}
}

// equals to

Point.prototype = {
  constructor() {},
  toString() {},
  toValue() {},
};

```
由于方法都定义在prototype对象上，类的新方法可添加在prototype对象上，Object.assign可一次添加多个方法
```js
class A {}
Object.assign(A.prototype, {
  toString() {},
  toValue() {},
})
```
### 1.2 类的内部所有定义的方法，都是不可枚举的（non-enumerable）。
内部调用的是Object.defineProperty(obj, "key", {});


### 1.3 类必须使用new调用，否则报错，这是跟普通构造函数的一个主要区别，后者不用new也能执行
```js
class A {
  constructor() {
    return this;
    // 默认返回实例对象
    return Object.create(null);
    // 设置返回其他
  }
}

A();
// TypeError: Class constructor A cannot be invoked without 'new'

// ES5
function A() { }
A();
// no errors
```

## 2. Tips
 - 1. strict mode
 - 2. no hoisting
 - 3. name property
 - 4. generator

## 3. 实例属性的新写法
- 1. 定义在constructor内
- 2. 定义在类的最顶层
```js
class A {
  // 1) 最顶层能
  c = "c";

  constructor() {
    // 2) constructor内部
    this.a = "a";
    this.b = "b";
    return this;
  }

  toString(args) {
    return "arguments: " + args
  }
}
let a = new A();
// A {c: "c", a: "a", b: "b"}
```

## 4. new.target
该属性一般用在constructor内，返回`new`命令作用于的那个构造函数
若constructor不是通过`new`命令或`Reflect.constructor()`调用的，`new.target`返回`undefined`;
该属性用来确定constructor如果被调用的

> 注意子类继承父类时，new.target返回子类
```js
class A {
  constructor(...args) {
    if (new.target === A) throw new Error(`A类必须使用 new 命令生成实例`);
    args.forEach(arg => this[arg] = arg);
  }
}


class B extends A {
  constructor(...args) {
    super(...args);
  }
}

let a = new A("tom", "age");
// Uncaught Error: A类必须使用 new 命令生成实例
let b = new B("tom", "age");
// {tom: "tom", age: "age"}
```

# 二、Class的继承
## 1. 子类挤成时，必须显示先调用super()；或省略constructor函数，则默认添加
> 原因是：ES6的继承机制不同，实质是先将父类实例对象的属性和方法，加到this上面，故必须先调用super(),在调用子类的构造函数修改this

## 2. Object.getPrototypeOf(className)
可用来判断子类是否继承自某个父类
```js
结合上述代码 类A 和 类B
Object.getPrototypeOf(B) === A
// true
```
