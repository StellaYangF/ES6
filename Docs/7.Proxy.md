### Proxy
#### 1. Introduction
* Proxy is a kind of meta programming
* Grammer:
 ```
  let proxy = new Proxy(target, handler);
 ```
 * Preview
 ```
  let handler = {
    get (target, name)  {
      if (name === 'prototype') {
        return Object.prototype;
      }
      return 'Hello, ' + name;
    },

    apply (target, thisBingding, args) {
      return args[0];
    },

    construct (target, args) {
      return { value: args[1]};
    }
  }

  // 此处不用箭头函数做target对象，箭头函数不能做构造函数
  let fproxy = new Proxy( function(x,y){
    return x + y;
  }, handler);

  fproxy(1,2); //1
  // invoke handler.apply()

  new fproxy(1,2);  // {value: 2};
  // invoke handler.construct()
  
  fproxy.property === Object.prototype;  // true
  fproxy.hello = 'Hello, hello'; // Hello, hello
  // invoke handler.get()
 ```

#### 2. Instance Methods
1. get(target, property, receiver)
* 1.1 重写.运算符
```
  let person = {
    name: 'Tom',
  };

  let proxy = new Proxy(person, {
    get (target, property) {
      if( property in target)  return target[property]
      else throw new ReferenceError(`Propery "${property}" does not exist.`)
    }
  })

  console.log(proxy.name) // Tom
  console.log(proxy.age) // Error
```

* 1.2 实现属性链式操作
```
  // Cannot use let decleration
  var double = n => n * 2;
  var pow = n => n* n;
  var reverseInt = n => n.toString().split("").reverse().join("") | 0;

  let pipe = (()=>{
    return value => {
      const GET = 'get';
      let funcStack = [];
      let target = {};
      let handler = {
        get (target, fnName, receiver) {
          if (fnName === GET) {
            return funcStack.reduce((value, fn) => fn(value), value);
          }
          funcStack.push(window[fnName]);
          return receiver;
        }
      };
      let proxy = new Proxy(target,handler);
      return proxy;
    }
  })();

  pipe(5).pow.double.reverseInt.get;  // 5
```

* 1.3 get拦截，生成dom节点
```
let target = {};
let handler = {
  get (target , property, receiver) {
    return ( attrs = {}, ...children ) => {
      const el = document.createElement(property);
      Object.keys(attrs).map(prop => {
        el.setAttribute(prop, attrs[prop]);
      });
      children.map(child => {
        child = typeof child === 'string' &&  document.createTextNode(child);
        el.appendChild(child);
      })

      return el;
    }
  }
};
const dom = new Proxy(target, handler);
const el = dom.div({},'hello');     
// <div>hello</div>
```

* 1.4 不可配置且不可写的属性，proxy在修改时会报错
```
const target = Object.defineProperty({}, 'foo', {
  value: 123,
  writable: false,
  configurable: false,
})

const handler = {
  get (target, property) {
    return 'abc';
  }
}
const proxy = new Proxy(target, handler);
proxy.foo;
// Uncaught TypeError: 'get' on proxy: 
// property 'foo' is a read-only and non-configurable data property 
// on the proxy target but the proxy did not return its actual value 
// (expected '123' but got 'abc')
```

* 1.5 实现继承
```
let proto = new Proxy({}, {
  get (target, property, receiver) {
    console.log(`GET ${property}`);
    return target[property] && undefined;
  }
});

let obj = Object.create(proto);
console.log(obj.name);
// GET name
// undefined
```

* 1.6 实现数组读取负数
```
function createArray (...elements) {
  let handler = {
    get (target, property, receiver) {
      let index = Number(property);
      property =  index < 0 ? String(target.length + index): index;
      return Reflect.get(target, property, receiver);
    }
  };

  let target = [...elements];
  return new Proxy(target, handler);
}

let arr = createArray('a', 'b', 'c');
console.log(arr[-1], arr[1]);
```

2. 实例方法set
* 定义： set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选
```
  let validator = {
    set (target, property, value, receiver) {
      if (property  === 'age') {
        if ( !Number.isInteger(value) {
          throw new TypeError('The age is not an integer');
        }
        if (value > 200) {
          throw new RangeError('The age seems invalid');
        }
      }
      obj[property] = value;
    }
  }
  const target = {};
  let person = new Proxy(target, validator);

  person.age = 100;
  person.age //100
  person.age = 'young'; //Error
  person.age = 300; //Errors
```

* 2.1内部属性不被读写
```
  // 工具函数
  const invariant = (key, action) => {
    if (key[0] === '_') {
      throw new Error(`Invalid attempt to ${action} private "${key}" property`);
    }
  }
  const GET = 'get';
  const SET = 'set';
  const target = {};

  const handler = {
    get (target, key) {
      invariant(key, GET);
      return target[key];
    },
    set (target, key, value) {
      invariant(key, SET);
      target[key] = value;
      return true;
    }
  };
  const proxy = new Proxy(target, handler);
  proxy._prop;
  proxy._prop = 'c';
  // Error: Invalid attempt to get private "_prop" property
```