# Generator
## 1. Introduction
This is also a resolution to handle async prgoramming.
```js
function* generator() {
  yield "Bonjour";
  yield "Madam";
  return "Bonjour!"
}

let gen = generator();
gen.next();
gen.next();
gen.next();
// { value: 'Bonjour', done: false }
// { value: 'Madam', done: false }
// { value: 'Bonjour!', done: true }
```

### 1.1 yeild expression
由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。

- 遍历器对象的next方法的运行逻辑如下。
  - 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。
  - 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。
  - 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。
  - 如果该函数没有return语句，则返回的对象的value属性值为undefined。

> 需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。
```js
function* f() {
  console.log("Performed!");
}

// 1） 调用f()并进行赋值时，f()不会执行，因其实Generator函数
let gen = f();

// 2） 只有调用其返回的对象的.next方法时，f()才会执行
setTimeout(()=>{
  gen.next()
},2000)
// Performed!
// { value: undefined, done: true }
```
> 注意： yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。

### 1.2 与Iterator接口的关系
- 任意一个对象的`Symbol.iterator`方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。
- 由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。
```js
const iterator = {};
iterator[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
  return 'end';
};

[...iterator]
// [ 1, 2, 3 ]
```
- Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。
```js
const gen = function* () {}
const g = gen();
g[Symbol.iterator]() === g;  // true
```

## 2. next method params
yield表达式无返回值，OR 总返回`undefined`;
next可带一个参数，作为上一个yield表达式返回值
> 例一:
```js
const gen = function* () {
  let r1 = yield 1;
  console.log(r1);
  let r2 = yield r1;
};

let g = gen();
g.next();     // 第一次返回值
g.next(2);    // 2作为第一次yield方法的返回值，并传入赋值给r1
g.next();
// {value: 1, done: false}
// {value: 4, done: false}
// {value: undefined, done: true}
```
> 例二：通过next方法参数，注入值
```js
function* f(x) {
  let y = 2 * (yield (x+ 1));
  let z = yield (y / 3);
  return (x + y + z);
} 

let gen = f(5);    // x: 5
gen.next();   // return 6  
gen.next(12); // return 8, yield return 12, y = 24
gen.next(13); // return 42, yield return 15, z= 13
// {value: 6, done: false}
// {value: 8, done: false}
// {value: 42, done: true}
```

> 例三：注入值
```js
function* dataConsumer() {
  console.log("Started!");
  console.log(`1. ${yield}`);
  console.log(`2. ${yield}`);
  return "End!";
}

let gen = dataConsumer();
gen.next();
gen.next("A");
gen.next("B");
/*Print records: */
// "Started!"
// "1. A"
// "2. B"
// "End!"

/* reutrn results: */
// {value: undefined, done: false}
// {value: undefined, done: false}
// {value: "End!", done: true}
```

> 例四：首次调用next就有返回值
```js
function wrapper(generatorFunction) {
  return function (...args) {
    let generatorObject = generatorFunction(...args);
    // 直接调用一次  输入参数给yield返回值用
    generatorObject.next();
    return generatorObject;
  }
}

const warpped = wrapper(function* () {
  console.log(`First input: ${yield}`);
  return "DONE";
})
warpped().next("hello");
```